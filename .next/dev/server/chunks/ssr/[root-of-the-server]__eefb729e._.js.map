{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAmBsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAqDsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MA2DsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAiEsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAgFsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAyEsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,gDAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///app/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport { FileText, Plus, Save, Sidebar as SidebarIcon, Trash2, Folder, FolderPlus, ChevronRight, ChevronDown } from 'lucide-react';\nimport { getNotes, readNote, saveNote, createNote, deleteItem, createFolder, NoteItem } from '@/lib/notes';\nimport { motion, AnimatePresence } from 'framer-motion';\n\nexport default function Home() {\n    const [notes, setNotes] = useState<NoteItem[]>([]);\n    const [activeNote, setActiveNote] = useState<string | null>(null);\n    const [content, setContent] = useState('');\n    const [sidebarOpen, setSidebarOpen] = useState(true);\n    const [expandedFolders, setExpandedFolders] = useState<Record<string, boolean>>({});\n\n    useEffect(() => {\n        refreshNotes();\n    }, []);\n\n    const refreshNotes = async () => {\n        const list = await getNotes();\n        setNotes(list);\n    };\n\n    const handleSelectNote = async (itemPath: string) => {\n        const text = await readNote(itemPath);\n        setActiveNote(itemPath);\n        setContent(text);\n    };\n\n    const handleDelete = async (e: React.MouseEvent, itemPath: string, name: string) => {\n        e.stopPropagation();\n        if (confirm(`Weet je zeker dat je '${name}' wilt verwijderen?`)) {\n            await deleteItem(itemPath);\n            if (activeNote === itemPath || activeNote?.startsWith(itemPath + '/')) {\n                setActiveNote(null);\n                setContent('');\n            }\n            await refreshNotes();\n        }\n    };\n\n    const handleSave = async () => {\n        if (activeNote) {\n            await saveNote(activeNote, content);\n            await refreshNotes();\n        }\n    };\n\n    const handleNewNote = async (folderPath = '') => {\n        const name = prompt('Naam voor nieuwe notitie:', 'Nieuwe Notitie');\n        if (!name) return;\n        const res = await createNote(name, folderPath);\n        if ('success' in res && res.path) {\n            await refreshNotes();\n            handleSelectNote(res.path);\n        }\n    };\n\n    const handleNewFolder = async (parentPath = '') => {\n        const name = prompt('Naam voor nieuwe map:', 'Nieuwe Map');\n        if (!name) return;\n        const res = await createFolder(name, parentPath);\n        if ('success' in res) {\n            setExpandedFolders(prev => ({ ...prev, [parentPath]: true }));\n            await refreshNotes();\n        }\n    };\n\n    const toggleFolder = (folderPath: string) => {\n        setExpandedFolders(prev => ({ ...prev, [folderPath]: !prev[folderPath] }));\n    };\n\n    const renderTree = (items: NoteItem[], depth = 0) => {\n        return items.map((item) => (\n            <div key={item.path}>\n                <div\n                    className={`note-item ${activeNote === item.path ? 'active' : ''}`}\n                    style={{ paddingLeft: `${depth * 15 + 20}px` }}\n                    onClick={() => item.type === 'folder' ? toggleFolder(item.path) : handleSelectNote(item.path)}\n                >\n                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', overflow: 'hidden', flex: 1 }}>\n                        {item.type === 'folder' ? (\n                            <>\n                                {expandedFolders[item.path] ? <ChevronDown size={14} /> : <ChevronRight size={14} />}\n                                <Folder size={16} color=\"#bb86fc\" />\n                            </>\n                        ) : (\n                            <FileText size={16} />\n                        )}\n                        <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>\n                            {item.title}\n                        </span>\n                    </div>\n                    <div className=\"item-actions\">\n                        {item.type === 'folder' && (\n                            <button className=\"action-btn\" onClick={(e) => { e.stopPropagation(); handleNewNote(item.path); }}>\n                                <Plus size={14} />\n                            </button>\n                        )}\n                        <button\n                            className=\"delete-btn\"\n                            onClick={(e) => handleDelete(e, item.path, item.title)}\n                        >\n                            <Trash2 size={14} />\n                        </button>\n                    </div>\n                </div>\n                {item.type === 'folder' && expandedFolders[item.path] && item.children && (\n                    <div>{renderTree(item.children, depth + 1)}</div>\n                )}\n            </div>\n        ));\n    };\n\n    return (\n        <div className=\"app-container\">\n            <motion.aside\n                initial={false}\n                animate={{ width: sidebarOpen ? 260 : 0 }}\n                className=\"sidebar\"\n            >\n                <div className=\"sidebar-header\">\n                    <span>Klompsidian</span>\n                    <div style={{ display: 'flex', gap: '5px' }}>\n                        <button onClick={() => handleNewFolder()} className=\"new-note-btn\" title=\"Nieuwe Map\" style={{ padding: '6px' }}>\n                            <FolderPlus size={18} />\n                        </button>\n                        <button onClick={() => handleNewNote()} className=\"new-note-btn\" title=\"Nieuwe Notitie\" style={{ padding: '6px' }}>\n                            <Plus size={18} />\n                        </button>\n                    </div>\n                </div>\n                <div style={{ flex: 1, overflowY: 'auto', paddingBottom: '20px' }}>\n                    {renderTree(notes)}\n                </div>\n            </motion.aside>\n\n            <main className=\"main-content\">\n                <div style={{ padding: '10px 20px', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n                    <button onClick={() => setSidebarOpen(!sidebarOpen)} style={{ background: 'transparent', border: 'none', color: 'var(--foreground)', cursor: 'pointer' }}>\n                        <SidebarIcon size={20} />\n                    </button>\n\n                    <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>\n                        {activeNote && (\n                            <>\n                                <span style={{ fontSize: '0.8rem', color: '#666', fontFamily: 'monospace' }}>{activeNote}</span>\n                                <button onClick={handleSave} className=\"new-note-btn\" style={{ padding: '4px 12px' }}>\n                                    <Save size={16} />\n                                </button>\n                            </>\n                        )}\n                    </div>\n                </div>\n\n                {activeNote ? (\n                    <div className=\"editor-container\">\n                        <div className=\"glass-panel\">\n                            <textarea\n                                className=\"markdown-input\"\n                                value={content}\n                                onChange={(e) => setContent(e.target.value)}\n                                placeholder=\"Typ hier je markdown...\"\n                            />\n                        </div>\n                        <div className=\"glass-panel preview-content\">\n                            <ReactMarkdown>{content}</ReactMarkdown>\n                        </div>\n                    </div>\n                ) : (\n                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#666', flexDirection: 'column' }}>\n                        <Folder size={48} style={{ marginBottom: '20px', opacity: 0.2 }} />\n                        Selecteer een notitie of maak een nieuwe aan\n                    </div>\n                )}\n            </main>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}}]
}