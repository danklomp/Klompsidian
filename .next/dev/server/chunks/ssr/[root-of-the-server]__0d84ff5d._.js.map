{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\n// Zorg dat de notes directory bestaat\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport async function getNotes() {\n    const files = fs.readdirSync(NOTES_DIR);\n    return files\n        .filter(file => file.endsWith('.md'))\n        .map(file => {\n            const content = fs.readFileSync(path.join(NOTES_DIR, file), 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            return {\n                name: file.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : file.replace('.md', ''),\n                path: file,\n            };\n        });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string) {\n    const filename = `${name}.md`;\n    const filePath = path.join(NOTES_DIR, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, name };\n}\n\nexport async function deleteNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAYsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\n// Zorg dat de notes directory bestaat\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport async function getNotes() {\n    const files = fs.readdirSync(NOTES_DIR);\n    return files\n        .filter(file => file.endsWith('.md'))\n        .map(file => {\n            const content = fs.readFileSync(path.join(NOTES_DIR, file), 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            return {\n                name: file.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : file.replace('.md', ''),\n                path: file,\n            };\n        });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string) {\n    const filename = `${name}.md`;\n    const filePath = path.join(NOTES_DIR, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, name };\n}\n\nexport async function deleteNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MA2BsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\n// Zorg dat de notes directory bestaat\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport async function getNotes() {\n    const files = fs.readdirSync(NOTES_DIR);\n    return files\n        .filter(file => file.endsWith('.md'))\n        .map(file => {\n            const content = fs.readFileSync(path.join(NOTES_DIR, file), 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            return {\n                name: file.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : file.replace('.md', ''),\n                path: file,\n            };\n        });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string) {\n    const filename = `${name}.md`;\n    const filePath = path.join(NOTES_DIR, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, name };\n}\n\nexport async function deleteNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAiCsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\n// Zorg dat de notes directory bestaat\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport async function getNotes() {\n    const files = fs.readdirSync(NOTES_DIR);\n    return files\n        .filter(file => file.endsWith('.md'))\n        .map(file => {\n            const content = fs.readFileSync(path.join(NOTES_DIR, file), 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            return {\n                name: file.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : file.replace('.md', ''),\n                path: file,\n            };\n        });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string) {\n    const filename = `${name}.md`;\n    const filePath = path.join(NOTES_DIR, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, name };\n}\n\nexport async function deleteNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MAuCsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\n// Zorg dat de notes directory bestaat\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport async function getNotes() {\n    const files = fs.readdirSync(NOTES_DIR);\n    return files\n        .filter(file => file.endsWith('.md'))\n        .map(file => {\n            const content = fs.readFileSync(path.join(NOTES_DIR, file), 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            return {\n                name: file.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : file.replace('.md', ''),\n                path: file,\n            };\n        });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string) {\n    const filename = `${name}.md`;\n    const filePath = path.join(NOTES_DIR, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, name };\n}\n\nexport async function deleteNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename.endsWith('.md') ? filename : `${filename}.md`);\n    if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;MA+CsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///app/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport { FileText, Plus, Save, Sidebar as SidebarIcon, Trash2 } from 'lucide-react';\nimport { getNotes, readNote, saveNote, createNote, deleteNote } from '@/lib/notes';\nimport { motion, AnimatePresence } from 'framer-motion';\n\nexport default function Home() {\n    const [notes, setNotes] = useState<{ name: string, title: string, path: string }[]>([]);\n    const [activeNote, setActiveNote] = useState<string | null>(null);\n    const [content, setContent] = useState('');\n    const [sidebarOpen, setSidebarOpen] = useState(true);\n\n    useEffect(() => {\n        refreshNotes();\n    }, []);\n\n    const refreshNotes = async () => {\n        const list = await getNotes();\n        setNotes(list);\n    };\n\n    const handleSelectNote = async (filename: string) => {\n        const text = await readNote(filename);\n        setActiveNote(filename);\n        setContent(text);\n    };\n\n    const handleDeleteNote = async (e: React.MouseEvent, filename: string) => {\n        e.stopPropagation();\n        if (confirm(`Weet je zeker dat je '${filename}' wilt verwijderen?`)) {\n            await deleteNote(filename);\n            if (activeNote === filename) {\n                setActiveNote(null);\n                setContent('');\n            }\n            await refreshNotes();\n        }\n    };\n\n    const handleSave = async () => {\n        if (activeNote) {\n            await saveNote(activeNote, content);\n            await refreshNotes();\n        }\n    };\n\n    const handleNewNote = async () => {\n        const name = `Nieuwe Notitie ${notes.length + 1}`;\n        const res = await createNote(name);\n        if ('success' in res) {\n            await refreshNotes();\n            handleSelectNote(`${name}.md`);\n        }\n    };\n\n    return (\n        <div className=\"app-container\">\n            {/* Sidebar */}\n            <motion.aside\n                initial={false}\n                animate={{ width: sidebarOpen ? 260 : 0 }}\n                className=\"sidebar\"\n            >\n                <div className=\"sidebar-header\">\n                    <span>Klompsidian</span>\n                    <button onClick={handleNewNote} className=\"new-note-btn\">\n                        <Plus size={18} />\n                    </button>\n                </div>\n                <div style={{ flex: 1, overflowY: 'auto' }}>\n                    {notes.map((note) => (\n                        <div\n                            key={note.path}\n                            className={`note-item ${activeNote === note.path ? 'active' : ''}`}\n                            onClick={() => handleSelectNote(note.path)}\n                        >\n                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', overflow: 'hidden' }}>\n                                <FileText size={16} />\n                                <span style={{\n                                    whiteSpace: 'nowrap',\n                                    overflow: 'hidden',\n                                    textOverflow: 'ellipsis'\n                                }}>\n                                    {note.title}\n                                </span>\n                            </div>\n                            <button\n                                className=\"delete-btn\"\n                                onClick={(e) => handleDeleteNote(e, note.path)}\n                                style={{ background: 'transparent', border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center' }}\n                            >\n                                <Trash2 size={14} />\n                            </button>\n                        </div>\n                    ))}\n                </div>\n            </motion.aside>\n\n            {/* Main Content */}\n            <main className=\"main-content\">\n                <div style={{ padding: '10px 20px', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between' }}>\n                    <button onClick={() => setSidebarOpen(!sidebarOpen)} style={{ background: 'transparent', border: 'none', color: 'var(--foreground)', cursor: 'pointer' }}>\n                        <SidebarIcon size={20} />\n                    </button>\n\n                    <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>\n                        {activeNote && (\n                            <>\n                                <span style={{ fontSize: '0.9rem', color: '#888' }}>{activeNote}</span>\n                                <button onClick={handleSave} className=\"new-note-btn\" style={{ padding: '4px 12px' }}>\n                                    <Save size={16} />\n                                </button>\n                            </>\n                        )}\n                    </div>\n                </div>\n\n                {activeNote ? (\n                    <div className=\"editor-container\">\n                        <div className=\"glass-panel\">\n                            <textarea\n                                className=\"markdown-input\"\n                                value={content}\n                                onChange={(e) => setContent(e.target.value)}\n                                placeholder=\"Typ hier je markdown...\"\n                            />\n                        </div>\n                        <div className=\"glass-panel preview-content\">\n                            <ReactMarkdown>{content}</ReactMarkdown>\n                        </div>\n                    </div>\n                ) : (\n                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#666' }}>\n                        Selecteer een notitie of maak een nieuwe aan\n                    </div>\n                )}\n            </main>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}}]
}