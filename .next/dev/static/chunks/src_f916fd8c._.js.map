{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MAmBsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MAqDsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MA2DsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MAiEsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MAgFsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,8CAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MAyEsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,gDAAA"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MA6FsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,4CAAA"}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/notes.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst NOTES_DIR = process.env.NOTES_PATH || '/notes';\n\nif (!fs.existsSync(NOTES_DIR)) {\n    fs.mkdirSync(NOTES_DIR, { recursive: true });\n}\n\nexport type NoteItem = {\n    name: string;\n    title: string;\n    path: string;\n    type: 'file' | 'folder';\n    children?: NoteItem[];\n};\n\nexport async function getNotes(dir = NOTES_DIR): Promise<NoteItem[]> {\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n    const result: NoteItem[] = [];\n\n    for (const item of items) {\n        const fullPath = path.join(dir, item.name);\n        const relativePath = path.relative(NOTES_DIR, fullPath);\n\n        if (item.isDirectory()) {\n            result.push({\n                name: item.name,\n                title: item.name,\n                path: relativePath,\n                type: 'folder',\n                children: await getNotes(fullPath),\n            });\n        } else if (item.name.endsWith('.md')) {\n            const content = fs.readFileSync(fullPath, 'utf-8');\n            const h1Match = content.match(/^#\\s+(.+)$/m);\n            result.push({\n                name: item.name.replace('.md', ''),\n                title: h1Match ? h1Match[1].trim() : item.name.replace('.md', ''),\n                path: relativePath,\n                type: 'file',\n            });\n        }\n    }\n\n    return result.sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;\n        return a.title.localeCompare(b.title);\n    });\n}\n\nexport async function readNote(filename: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    if (!fs.existsSync(filePath)) return '';\n    return fs.readFileSync(filePath, 'utf-8');\n}\n\nexport async function saveNote(filename: string, content: string) {\n    const filePath = path.join(NOTES_DIR, filename);\n    fs.writeFileSync(filePath, content, 'utf-8');\n    return { success: true };\n}\n\nexport async function createNote(name: string, folderPath = '') {\n    const filename = name.endsWith('.md') ? name : `${name}.md`;\n    const filePath = path.join(NOTES_DIR, folderPath, filename);\n    if (fs.existsSync(filePath)) return { error: 'Bestand bestaat al' };\n    fs.writeFileSync(filePath, '# ' + name, 'utf-8');\n    return { success: true, path: path.join(folderPath, filename) };\n}\n\nexport async function createFolder(name: string, parentPath = '') {\n    const folderPath = path.join(NOTES_DIR, parentPath, name);\n    if (fs.existsSync(folderPath)) return { error: 'Map bestaat al' };\n    fs.mkdirSync(folderPath, { recursive: true });\n    return { success: true };\n}\n\nexport async function deleteItem(itemPath: string) {\n    const fullPath = path.join(NOTES_DIR, itemPath);\n    if (fs.existsSync(fullPath)) {\n        const stats = fs.statSync(fullPath);\n        if (stats.isDirectory()) {\n            fs.rmSync(fullPath, { recursive: true, force: true });\n        } else {\n            fs.unlinkSync(fullPath);\n        }\n    }\n    return { success: true };\n}\n\nexport async function moveItem(oldPath: string, newParentPath: string) {\n    const sourcePath = path.join(NOTES_DIR, oldPath);\n    const itemName = path.basename(oldPath);\n    const destinationPath = path.join(NOTES_DIR, newParentPath, itemName);\n\n    if (!fs.existsSync(sourcePath)) return { error: 'Bronbestand bestaat niet' };\n    if (fs.existsSync(destinationPath)) return { error: 'Doelbestand bestaat al' };\n\n    fs.renameSync(sourcePath, destinationPath);\n    return { success: true };\n}\n\nexport async function searchNotes(query: string): Promise<NoteItem[]> {\n    const results: NoteItem[] = [];\n    const searchInDir = async (dir: string) => {\n        const items = fs.readdirSync(dir, { withFileTypes: true });\n        for (const item of items) {\n            const fullPath = path.join(dir, item.name);\n            const relativePath = path.relative(NOTES_DIR, fullPath);\n\n            if (item.isDirectory()) {\n                await searchInDir(fullPath);\n            } else if (item.name.endsWith('.md')) {\n                const content = fs.readFileSync(fullPath, 'utf-8');\n                const h1Match = content.match(/^#\\s+(.+)$/m);\n                const title = h1Match ? h1Match[1].trim() : item.name.replace('.md', '');\n\n                if (\n                    title.toLowerCase().includes(query.toLowerCase()) ||\n                    content.toLowerCase().includes(query.toLowerCase())\n                ) {\n                    results.push({\n                        name: item.name.replace('.md', ''),\n                        title: title,\n                        path: relativePath,\n                        type: 'file',\n                    });\n                }\n            }\n        }\n    };\n\n    await searchInDir(NOTES_DIR);\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;MAyGsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,+CAAA"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///app/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useEffect } from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport { FileText, Plus, Save, Sidebar as SidebarIcon, Trash2, Folder, FolderPlus, ChevronRight, ChevronDown, Eye, Edit3, Search, X } from 'lucide-react';\nimport { getNotes, readNote, saveNote, createNote, deleteItem, createFolder, moveItem, searchNotes, NoteItem } from '@/lib/notes';\nimport { motion, AnimatePresence } from 'framer-motion';\n\nexport default function Home() {\n    const [notes, setNotes] = useState<NoteItem[]>([]);\n    const [activeNote, setActiveNote] = useState<string | null>(null);\n    const [content, setContent] = useState('');\n    const [sidebarOpen, setSidebarOpen] = useState(true);\n    const [expandedFolders, setExpandedFolders] = useState<Record<string, boolean>>({});\n    const [draggingPath, setDraggingPath] = useState<string | null>(null);\n    const [dropTarget, setDropTarget] = useState<string | null>(null);\n    const [viewMode, setViewMode] = useState<'edit' | 'preview'>('edit');\n    const [isSaving, setIsSaving] = useState(false);\n    const [searchQuery, setSearchQuery] = useState('');\n    const [searchResults, setSearchResults] = useState<NoteItem[] | null>(null);\n\n    useEffect(() => {\n        refreshNotes();\n    }, []);\n\n    useEffect(() => {\n        if (!activeNote || viewMode !== 'edit') return;\n\n        const timer = setTimeout(async () => {\n            setIsSaving(true);\n            try {\n                await saveNote(activeNote, content);\n                // We don't necessarily need to refresh notes list on every keystroke save,\n                // but we might want to if titles are based on content (H1)\n                const list = await getNotes();\n                setNotes(list);\n            } catch (error) {\n                console.error('Failed to autosave:', error);\n            } finally {\n                setIsSaving(false);\n            }\n        }, 500); // 500ms debounce\n\n        return () => clearTimeout(timer);\n    }, [content, activeNote, viewMode]);\n\n    useEffect(() => {\n        const handleSearch = async () => {\n            if (searchQuery.trim().length > 1) {\n                const results = await searchNotes(searchQuery);\n                setSearchResults(results);\n            } else {\n                setSearchResults(null);\n            }\n        };\n\n        const timer = setTimeout(handleSearch, 300);\n        return () => clearTimeout(timer);\n    }, [searchQuery]);\n\n    const refreshNotes = async () => {\n        const list = await getNotes();\n        setNotes(list);\n    };\n\n    const handleSelectNote = async (itemPath: string) => {\n        const text = await readNote(itemPath);\n        setActiveNote(itemPath);\n        setContent(text);\n        // Start always in edit mode when selecting a new note\n        setViewMode('edit');\n    };\n\n    const handleDelete = async (e: React.MouseEvent, itemPath: string, name: string) => {\n        e.stopPropagation();\n        if (confirm(`Weet je zeker dat je '${name}' wilt verwijderen?`)) {\n            await deleteItem(itemPath);\n            if (activeNote === itemPath || activeNote?.startsWith(itemPath + '/')) {\n                setActiveNote(null);\n                setContent('');\n            }\n            await refreshNotes();\n        }\n    };\n\n    const handleSave = async () => {\n        if (activeNote) {\n            await saveNote(activeNote, content);\n            await refreshNotes();\n        }\n    };\n\n    const handleNewNote = async (folderPath = '') => {\n        const name = prompt('Naam voor nieuwe notitie:', 'Nieuwe Notitie');\n        if (!name) return;\n        const res = await createNote(name, folderPath);\n        if ('success' in res && res.path) {\n            await refreshNotes();\n            handleSelectNote(res.path);\n        }\n    };\n\n    const handleNewFolder = async (parentPath = '') => {\n        const name = prompt('Naam voor nieuwe map:', 'Nieuwe Map');\n        if (!name) return;\n        const res = await createFolder(name, parentPath);\n        if ('success' in res) {\n            setExpandedFolders(prev => ({ ...prev, [parentPath]: true }));\n            await refreshNotes();\n        }\n    };\n\n    const toggleFolder = (folderPath: string) => {\n        setExpandedFolders(prev => ({ ...prev, [folderPath]: !prev[folderPath] }));\n    };\n\n    // Drag and Drop handlers\n    const onDragStart = (e: React.DragEvent, path: string) => {\n        setDraggingPath(path);\n        e.dataTransfer.setData('text/plain', path);\n        e.dataTransfer.effectAllowed = 'move';\n    };\n\n    const onDragOver = (e: React.DragEvent, path: string, type: string) => {\n        e.stopPropagation();\n        if (type === 'folder' && draggingPath !== path && !path.startsWith(draggingPath + '/')) {\n            e.preventDefault();\n            setDropTarget(path);\n        } else if (path === '' && draggingPath) { // Root drop\n            e.preventDefault();\n            setDropTarget('');\n        }\n    };\n\n    const onDrop = async (e: React.DragEvent, targetPath: string) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const sourcePath = e.dataTransfer.getData('text/plain');\n        setDropTarget(null);\n        setDraggingPath(null);\n\n        if (sourcePath && sourcePath !== targetPath && !targetPath.startsWith(sourcePath + '/')) {\n            const res = await moveItem(sourcePath, targetPath);\n            if ('success' in res) {\n                if (activeNote === sourcePath) {\n                    const fileName = sourcePath.split('/').pop();\n                    setActiveNote(targetPath === '' ? fileName! : `${targetPath}/${fileName}`);\n                }\n                await refreshNotes();\n            } else if ('error' in res) {\n                alert(res.error);\n            }\n        }\n    };\n\n    const renderTree = (items: NoteItem[], depth = 0) => {\n        return items.map((item) => (\n            <div key={item.path}>\n                <div\n                    className={`note-item ${activeNote === item.path ? 'active' : ''} ${dropTarget === item.path ? 'drop-target' : ''} ${draggingPath === item.path ? 'dragging' : ''}`}\n                    style={{ paddingLeft: `${depth * 15 + 20}px` }}\n                    draggable\n                    onDragStart={(e) => onDragStart(e, item.path)}\n                    onDragOver={(e) => onDragOver(e, item.path, item.type)}\n                    onDragLeave={() => setDropTarget(null)}\n                    onDrop={(e) => onDrop(e, item.path)}\n                    onClick={() => item.type === 'folder' ? toggleFolder(item.path) : handleSelectNote(item.path)}\n                >\n                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', overflow: 'hidden', flex: 1 }}>\n                        {item.type === 'folder' ? (\n                            <>\n                                {expandedFolders[item.path] ? <ChevronDown size={14} /> : <ChevronRight size={14} />}\n                                <Folder size={16} color=\"#bb86fc\" />\n                            </>\n                        ) : (\n                            <FileText size={16} />\n                        )}\n                        <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>\n                            {item.title}\n                        </span>\n                    </div>\n                    <div className=\"item-actions\">\n                        {item.type === 'folder' && (\n                            <button className=\"action-btn\" onClick={(e) => { e.stopPropagation(); handleNewNote(item.path); }}>\n                                <Plus size={14} />\n                            </button>\n                        )}\n                        <button\n                            className=\"delete-btn\"\n                            onClick={(e) => handleDelete(e, item.path, item.title)}\n                        >\n                            <Trash2 size={14} />\n                        </button>\n                    </div>\n                </div>\n                {item.type === 'folder' && expandedFolders[item.path] && item.children && (\n                    <div>{renderTree(item.children, depth + 1)}</div>\n                )}\n            </div>\n        ));\n    };\n\n    return (\n        <div className=\"app-container\">\n            <motion.aside\n                initial={false}\n                animate={{ width: sidebarOpen ? 260 : 0 }}\n                className=\"sidebar\"\n                onDragOver={(e) => onDragOver(e, '', 'folder')}\n                onDrop={(e) => onDrop(e, '')}\n            >\n                <div className=\"sidebar-header\">\n                    <span>Klompsidian</span>\n                    <div style={{ display: 'flex', gap: '5px' }}>\n                        <button onClick={() => handleNewFolder()} className=\"new-note-btn\" title=\"Nieuwe Map\" style={{ padding: '6px' }}>\n                            <FolderPlus size={18} />\n                        </button>\n                        <button onClick={() => handleNewNote()} className=\"new-note-btn\" title=\"Nieuwe Notitie\" style={{ padding: '6px' }}>\n                            <Plus size={18} />\n                        </button>\n                    </div>\n                </div>\n\n                <div style={{ padding: '10px 15px' }}>\n                    <div className=\"search-container\" style={{ position: 'relative', display: 'flex', alignItems: 'center' }}>\n                        <Search size={14} style={{ position: 'absolute', left: '10px', color: '#666' }} />\n                        <input\n                            type=\"text\"\n                            placeholder=\"Doorzoek notities...\"\n                            value={searchQuery}\n                            onChange={(e) => setSearchQuery(e.target.value)}\n                            style={{\n                                width: '100%',\n                                background: 'rgba(255, 255, 255, 0.05)',\n                                border: '1px solid var(--border)',\n                                borderRadius: '6px',\n                                padding: '6px 30px',\n                                fontSize: '0.85rem',\n                                color: 'var(--foreground)',\n                                outline: 'none'\n                            }}\n                        />\n                        {searchQuery && (\n                            <X\n                                size={14}\n                                style={{ position: 'absolute', right: '10px', color: '#666', cursor: 'pointer' }}\n                                onClick={() => setSearchQuery('')}\n                            />\n                        )}\n                    </div>\n                </div>\n\n                <div style={{ flex: 1, overflowY: 'auto', paddingBottom: '20px' }}>\n                    {searchResults ? (\n                        <div className=\"search-results\">\n                            <div style={{ padding: '5px 15px', fontSize: '0.7rem', color: '#666', textTransform: 'uppercase', letterSpacing: '0.05em' }}>\n                                {searchResults.length} resultaten gevonden\n                            </div>\n                            {renderTree(searchResults)}\n                        </div>\n                    ) : (\n                        renderTree(notes)\n                    )}\n                </div>\n            </motion.aside>\n\n            <main className=\"main-content\">\n                <div style={{ padding: '10px 20px', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n                    <button onClick={() => setSidebarOpen(!sidebarOpen)} style={{ background: 'transparent', border: 'none', color: 'var(--foreground)', cursor: 'pointer' }}>\n                        <SidebarIcon size={20} />\n                    </button>\n\n                    <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>\n                        {activeNote && (\n                            <>\n                                <span style={{ fontSize: '0.8rem', color: '#666', fontFamily: 'monospace' }}>{activeNote}</span>\n                                <div className=\"mode-toggle\">\n                                    <button\n                                        className={`toggle-btn ${viewMode === 'edit' ? 'active' : ''}`}\n                                        onClick={() => setViewMode('edit')}\n                                        title=\"Bewerk Modus\"\n                                    >\n                                        <Edit3 size={16} />\n                                    </button>\n                                    <button\n                                        className={`toggle-btn ${viewMode === 'preview' ? 'active' : ''}`}\n                                        onClick={() => setViewMode('preview')}\n                                        title=\"Lees Modus\"\n                                    >\n                                        <Eye size={16} />\n                                    </button>\n                                </div>\n                                <button\n                                    onClick={handleSave}\n                                    className={`new-note-btn ${isSaving ? 'saving' : ''}`}\n                                    style={{ padding: '6px 12px', minWidth: '40px', display: 'flex', justifyContent: 'center' }}\n                                    disabled={isSaving}\n                                >\n                                    {isSaving ? (\n                                        <motion.div\n                                            animate={{ rotate: 360 }}\n                                            transition={{ duration: 1, repeat: Infinity, ease: \"linear\" }}\n                                        >\n                                            <Save size={16} />\n                                        </motion.div>\n                                    ) : (\n                                        <Save size={16} />\n                                    )}\n                                </button>\n                            </>\n                        )}\n                    </div>\n                </div>\n\n                {activeNote ? (\n                    <div className=\"editor-view-container\">\n                        {viewMode === 'edit' ? (\n                            <div className=\"glass-panel editor-only\">\n                                <textarea\n                                    className=\"markdown-input\"\n                                    value={content}\n                                    onChange={(e) => setContent(e.target.value)}\n                                    placeholder=\"Typ hier je markdown...\"\n                                    autoFocus\n                                />\n                            </div>\n                        ) : (\n                            <div className=\"glass-panel preview-only\">\n                                <div className=\"preview-content\">\n                                    <ReactMarkdown>{content}</ReactMarkdown>\n                                </div>\n                            </div>\n                        )}\n                    </div>\n                ) : (\n                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#666', flexDirection: 'column' }}>\n                        <Folder size={48} style={{ marginBottom: '20px', opacity: 0.2 }} />\n                        Selecteer een notitie of maak een nieuwe aan\n                    </div>\n                )}\n            </main>\n        </div>\n    );\n}\n"],"names":[],"mappings":"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"}}]
}